<!-- 3D Globe code  -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Globe with Rays</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background-color: black;
      color: white;
      height: 100vh;
      overflow: visible;
      overflow-x: hidden;
    }
    .section-container {
      justify-content: center; /* Center horizontally */
      align-items: center;
      display: flex;
      width: 100%;
      height: 100vh;
      position: relative;
      background-image: url('https://cdn.shopify.com/s/files/1/0897/3572/5361/files/Black_and_White_Minimalist_Night_Sky_Star_Scenery_Earth_Hour_Instagram_Post_1584_x_1000_px_2000_x.png?v=1733811748');
      background-size: cover;
      background-position: center;
      overflow: hidden;
      justify-content: space-between;
      flex-wrap: wrap;
      padding: 10px;
    }
   #globe-container {
    aspect-ratio: 1;
    margin: auto;
    padding: 10px;
    width: 500px; 
    max-width: 900px; 
    background-color: transparent;
    position: relative;  
    left: 15%;
    transform: translateX(-50%); 
    animation: fall-in 5s ease-out forwards;
    overflow: visible;
    }

    @keyframes fall-in {
    0% {
        top: -100%; /* Start off-screen */
        transform: translateX(-50%); /* Keep horizontal center */
    }
    100% {
        top: 40%; /* Vertical center */
        transform: translate(-50%, -50%); /* Horizontal and vertical center */
    }
    }

    .project-column {
      width: 40%;
      height: 100vh;
      transition: all 0.9s ease-in;
      overflow-y: hidden;
      overflow-x: hidden;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      background-color: transparent;
      padding: 20px;
      position: relative;
      flex-wrap: wrap;
    }
    .project-card {
      opacity: 0;
      transition: all 0.5s ease-out;
      background-color: #333;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      overflow: hidden;
      text-align: center;
      color: white;
      width: 40%;
      position: fixed;
      bottom: 20px;
      right: 20px;
    }
    .project-card.active {
      opacity: 1;
      transform: translateY(0);
    }
    .project-card img {
      width: 100%;
      height: 300px;
      object-fit: cover;
    }
    .project-details {
      padding: 10px;
    }
    .project-details h3 {
      margin: 0 0 10px 0;
      font-size: 15px;
    }
    .project-details p {
      margin: 0 0 10px 0;
      color: #ddd;
    }
    .read-more {
      color: #007bff;
      text-decoration: none;
      font-weight: bold;
    }
    .read-more:hover {
      text-decoration: underline;
    }
    /* Medium devices (up to 768px) */
@media (max-width: 768px) {
    #globe-container {
        width: 700px;
        margin-top: -5%;
        left: 50%;
        transform: translateX(-50%);
    }
    .project-column {
        width: 100%;
        box-sizing: border-box;
    }
    .project-card {
        width: 90%;               /* adjust width for mobile */
        position: fixed;
        bottom: 5%;
        right: 5%;  
        display: none;            /* hide initially */
        z-index: 999;             /* appear on top */
    }
    .project-card.active {
        display: block;
    }
    .project-card img {
        width: 100%;
        object-fit: cover;
    }
}

/* Small devices (up to 480px) */
@media (max-width: 480px) {
    #globe-container {
        width: 90%;               /* scale down globe */
        margin-top: -20%;
        left: 50%;
        transform: translateX(-50%);
    }
    .project-column {
        width: 100%;
        box-sizing: border-box;
        display: block;
    }
    .project-card {
        width: 95%;               /* smaller width for tiny screens */
        position: fixed;
        bottom: 2%;
        right: 2%;  
        display: none;
        z-index: 999;
    }
    .project-card.active {
        display: block;
    }
    .project-card img {
        width: 100%;
        object-fit: cover;
    }
}

  </style>
</head>
<body>
  <section class="section-container">
    <div id="globe-container"></div>
    <div class="project-column" id="project-column"></div>
  </section>

  <!-- Importing necessary libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const container = document.getElementById("globe-container");
      const projectColumn = document.getElementById("project-column");

      const radius = 170; // Globe radius
      const points = []; // Store points for raycasting
      const extraRays = []; // Store decorative rays
      const projectRays = []; // Store rays for projects

      // Initialize Renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.offsetWidth, container.offsetHeight);
      renderer.setPixelRatio(container.devicePixelRatio); // Improve rendering
      container.appendChild(renderer.domElement);

      // Ensure canvas is resized correctly
      function resizeCanvas() {
        renderer.setSize(container.clientWidth, container.clientHeight);
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
      }

      // Create Scene and Camera
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 2000);
      camera.position.z = 500;

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      
      // Load Globe Texture (dotted texture)
      const globeTexture = new THREE.TextureLoader().load("https://cdn.shopify.com/s/files/1/0723/7071/6894/files/01-3.jpg?v=1734014475");
    // Create the main globe material (using Phong for texture and basic lighting)
    const globeMaterial = new THREE.MeshPhongMaterial({
      map: globeTexture,
      emissive: 0x061534,
      emissiveIntensity: 0.5,
      transparent: true,
      opacity: 0.88,
    });
    // Create a custom ShaderMaterial to create the inner border glow effect
    const borderGlowMaterial = new THREE.ShaderMaterial({
      uniforms: {
        glowColor: { value: new THREE.Color(0x00ffff) }, // blue color for the glow
        borderWidth: { value: 0.09 },  // Controls the width of the border glow
        glowIntensity: { value: 1},
      },
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        void main() {
          vNormal = normalize( normalMatrix * normal );
          vPosition = position; // Pass position for edge detection
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
      `,
      fragmentShader: `
        uniform vec3 glowColor;
        uniform float borderWidth;
        varying vec3 vNormal;
        varying vec3 vPosition;
        
        void main() {
          // Calculate the intensity based on the angle of the normal
          float edgeIntensity = 1.0 - smoothstep(0.9, 1.0, abs(vNormal.z)); // Detect edges based on normal direction
          
          // Apply the glow effect on the border
          vec3 glow = glowColor * edgeIntensity * borderWidth; // Glow around the edges

          // Just apply the glow without modifying texture color
          gl_FragColor = vec4(glow, 0.3); // Only the glow color at the edges
        }
      `,
      side: THREE.FrontSide,
      blending: THREE.AdditiveBlending,
      transparent: true,
    });

    // Create the globe geometry (higher resolution for smooth appearance)
    const globeGeometry = new THREE.SphereGeometry(radius, 100, 100);  // Higher resolution

    // Create the globe mesh (with the original globe material)
    const globeMesh = new THREE.Mesh(globeGeometry, globeMaterial);
    scene.add(globeMesh);

    // Create a larger sphere for the border glow (this will go around the globe)
    const glowGeometry = new THREE.SphereGeometry(radius + 0.1, 100, 100); // Slightly larger than the globe
    const glowMesh = new THREE.Mesh(glowGeometry, borderGlowMaterial); // Apply the border glow material
    scene.add(glowMesh);
      
      const atmosphereGeometry = new THREE.SphereGeometry(radius + 25, 180, 180); // Slightly larger than the globe
      const atmosphereMaterial = new THREE.ShaderMaterial({
        uniforms: {
        glowColor: { value: new THREE.Color(0x007bff) }, // White color for the glow
        borderWidth: { value: 0.5 },  // Controls the width of the border glow
      },
        vertexShader: `
          varying vec3 vNormal;
          void main() {
            vNormal = normalize( normalMatrix * normal );
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
          }
        `,
        fragmentShader: `
          varying vec3 vNormal;
          void main() {
            float intensity = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.5); // Adjust intensity for neon effect
            vec3 glowColor = vec3(0.0, 0.482, 1.0); // Equivalent to 0x007bff
            gl_FragColor = vec4(glowColor, 1.0) * intensity * 1.3;  // Increased intensity for brightness
          }
        `,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        transparent: true,
      });

      const atmosphereMesh = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
      scene.add(atmosphereMesh);

      // Add Ambient and Directional Lighting
      const ambientLight = new THREE.AmbientLight(0xbbbbbb);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.85);
      directionalLight.position.set(100, 100, 500);
      scene.add(directionalLight);

      // Function to convert latitude/longitude to 3D coordinates
      function latLngToVector3(lat, lng, radius) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lng + 180) * (Math.PI / 180);
        const x = -(radius * Math.sin(phi) * Math.cos(theta));
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(phi) * Math.sin(theta);
        return new THREE.Vector3(x, y, z);
      }

      const baseDots = []; // Store base dots for interaction
      // Add Rays and Project Points
      function addProjectRays(projects, radius) {
        projects.forEach((project, index) => {

          const startPosition = latLngToVector3(project.lat, project.lng, radius);
          let endPosition = startPosition.clone().normalize().multiplyScalar(radius + 3); // Base length for the ray

          // Unified material for ray and layered effect
          const rayMaterial = new THREE.LineBasicMaterial({
            color: 0xffffff,
            linewidth: 1.5, 
            transparent: true,
            opacity: 0.6, // Brighter opacity for glowing effect
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide,
          });

          // Create the main ray (base ray)
          const rayGeometry = new THREE.BufferGeometry().setFromPoints([startPosition, endPosition]);
          const ray = new THREE.Line(rayGeometry, rayMaterial);
          ray.userData.projectIndex = index;  // Link the ray to project index
          projectRays.push(ray);
          scene.add(ray);

          // Create the layered rays using the same material but progressively reduce opacity
          for (let i = 1; i <= 5; i++) {
            // Adjust the end position for each layer by increasing length
            const layeredEndPosition = startPosition.clone().normalize().multiplyScalar(radius + 10 + i * 3);

            // Adjust opacity progressively for the layer (instead of using a separate material)
            rayMaterial.opacity = 0.9 / i;  // Decrease opacity gradually for each layer

            // Create the layered ray geometry using the same material
            const layeredRayGeometry = new THREE.BufferGeometry().setFromPoints([startPosition, layeredEndPosition]);
            const layeredRay = new THREE.Line(layeredRayGeometry, rayMaterial); // Use the same material
            scene.add(layeredRay);
          }

          // Add small white sphere for the project point at the end of the ray
          const pointGeometry = new THREE.SphereGeometry(0.7, 10, 10);  // Slightly larger size
          const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
          const pointMesh = new THREE.Mesh(pointGeometry, pointMaterial);
          pointMesh.position.copy(startPosition); // Position the point at the end of the ray
          pointMesh.userData.projectIndex = index; // Link to project index
          baseDots.push(pointMesh); // Add to baseDots array
          scene.add(pointMesh);
        });
      }

      // Function to add decorative rays with blur shadow effect
      function addDecorativeRays(radius) {
        const numberOfRays = 100; // Number of decorative rays to add

        for (let i = 0; i < numberOfRays; i++) {
          // Generate random latitude and longitude for each ray
          const randomLat = Math.random() * 180 - 90;
          const randomLng = Math.random() * 360 - 180;
          const startPosition = latLngToVector3(randomLat, randomLng, radius);
          const endPosition = startPosition.clone().normalize().multiplyScalar(radius + 20);

          // Create the geometry for the base ray
          const rayGeometry = new THREE.BufferGeometry().setFromPoints([startPosition, endPosition]);

          // Shader material for the glow effect
          const rayMaterial = new THREE.ShaderMaterial({
            uniforms: {
              color: { value: new THREE.Color(0xffffff) },
              opacity: { value: 0.6 },
            },
            vertexShader: `
              varying vec3 vPosition;
              void main() {
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
              }
            `,
            fragmentShader: `
              uniform vec3 color;
              uniform float opacity;
              varying vec3 vPosition;

              void main() {
                float distanceFactor = length(vPosition) / 200.0;
                float alpha = opacity * (1.0 - distanceFactor);
                gl_FragColor = vec4(color, alpha);
              }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
          });
          
          // Create and add the base ray to the scene
          const ray = new THREE.Line(rayGeometry, rayMaterial);
          extraRays.push(ray);
          scene.add(ray);

          // Create layered rays for the blur shadow effect
          for (let j = 1; j <= 5; j++) {
            const layeredEndPosition = startPosition.clone().normalize().multiplyScalar(radius + 10 + j * 20);
            const layeredRayGeometry = new THREE.BufferGeometry().setFromPoints([startPosition, layeredEndPosition]);

            const layeredRayMaterial = rayMaterial.clone();
            layeredRayMaterial.uniforms.opacity.value = 0.2 / j; // Reduce opacity for each layer

            const layeredRay = new THREE.Line(layeredRayGeometry, layeredRayMaterial);
            scene.add(layeredRay);
          }

          // Add a small white sphere at the start position for visual effect
          const pointGeometry = new THREE.SphereGeometry(0.7, 10, 10); // Sphere size
          // Create the material with transparency and opacity
          const pointMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff,       // White color
            transparent: true,     // Enable transparency
            opacity: 0.3,           // Set the desired opacity (value between 0 and 1)
          });

          const pointMesh = new THREE.Mesh(pointGeometry, pointMaterial);
          pointMesh.position.copy(startPosition); // Position at the ray's start point

          baseDots.push(pointMesh); // Add to the baseDots array for potential interactions
          scene.add(pointMesh);
        }
      }

      // Full Project data with 13 projects
      const projectData = [
        { title: "Gawharet Alrasefa Flat", lat: 23.422510, lng: 45.826168, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/21_add3d2b4-58d2-4806-bdd1-297b686f9e93.jpg?v=1726778305", description: "A luxury transformation focusing on creating serene, elegant interiors with high-end materials and finishes.", readMoreLink: "Gawharet Alrasefa Flat Project" },
        { title: "Almalqa Project", lat: 21.774265, lng: 46.738586, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/MASTER_BEDROOM_SHOT-1_94399ef4-fc9c-487b-b094-8e850873a8f8.jpg?v=1726779778", description: "A stylish project with contemporary designs, focusing on comfort and luxury for the modern home.", readMoreLink: "Almalqa Project" },
        { title: "Bouvardia City", lat: 25.492500, lng: 43.177570, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/MAJLIS_SHOT-4_EDIT_a027b344-ad0e-4aa6-88c5-b83346fd0d04.jpg?v=1726778564", description: "A luxury interior project with a modern aesthetic, featuring custom lighting and elegant furniture pieces.", readMoreLink: "Bouvardia City Project" },
        { title: "Jeddah", lat: 21.492500, lng: 42.177570, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/RECEPTION_SHOT_6_d4111a69-012f-411e-b826-60abec2df2c1.jpg?v=1726778627", description: "Luxury transformation.", readMoreLink: "Jeddah Project" },
        { title: "Sodic West", lat: 26.422510, lng: 30.7832, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/LIVING_ROOM_SHOT_2_6eef9ff1-80b7-420e-bad6-18b7f447f893.jpg?v=1726779372", description: "Modern, luxurious bespoke furniture.", readMoreLink: "Sodic West Project" },
        { title: "Royal City", lat: 23.422510, lng: 27.7832, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/38_ae072c93-358c-4367-a1cc-7c9d1492e272.jpg?v=1726779312", description: "Sophisticated design with modern decor.", readMoreLink: "Royal City Project" },
        { title: "Azzar", lat: 28.422510, lng: 28.7832, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/MAJLIS_SHOT-4_EDIT_a027b344-ad0e-4aa6-88c5-b83346fd0d04.jpg?v=1726778564", description: "Modern, elegant design with custom furniture.", readMoreLink: "Azzar Project" },
        { title: "Green 4", lat: 26.422510, lng: 31.7832, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/LIVING_ROOM_SHOT_3-01_a010da22-035e-4864-8196-730b9f40de61.jpg?v=1726779695", description: "A sleek and minimalist project that incorporates contemporary designs and premium materials for a refined living space.", readMoreLink: "Green 4 Project" },
        { title: "Kayan", lat: 26.422510, lng: 25.7832, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/Reception_shot_1-01_0d35f2be-31fd-445a-9581-2a5d7c42a91f.jpg?v=1726778752", description: "Elegant design with custom furniture.", readMoreLink: "Kayan Project" },
        { title: "Mountain View Hyde Park", lat: 27.422510, lng: 26.7832, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/Reception_Shot_7_baaa7526-7652-48e0-a1ec-af70fb768bde.jpg?v=1726778836", description: "Luxury design with contemporary decor.", readMoreLink: "Mountain View Project" },
        { title: "New Cairo", lat: 25.422510, lng: 32.7832, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/RECEPTION_SHOOT_3-01_5b2393ed-c3df-4505-a9b6-c8184530ba01.jpg?v=1726779441", description: "Contemporary, luxury interiors.", readMoreLink: "New Cairo Project" },
        { title: "New Giza", lat: 24.910, lng: 29.32, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/RECEPTION_SHOT_1-01_fe6764f3-023a-4646-a474-0c6c1843e268.jpg?v=1726779495", description: "Sleek, modern interiors.", readMoreLink: "New Giza Project" },
        { title: "The Allegria", lat: 23.9, lng: 30.1, image: "https://cdn.shopify.com/s/files/1/0897/3572/5361/files/ENTRANCE_SHOT_1s-01.jpg?v=1726779550", description: "Luxury transformation with custom furniture.", readMoreLink: "The Allegria Project" }
      ];

      // Add Rays and Points for projects
      addProjectRays(projectData, radius);
      
      // Add decorative rays
      addDecorativeRays(radius);

      // Orbit Controls (with scroll enabled on project column)
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05; // Adjust damping factor for smoothness
      controls.rotateSpeed = 0.5; // Adjust rotation speed
      controls.enableZoom = true;
      controls.zoomSpeed = 1.0;
      controls.enablePan = false;

      // Allow scrolling on the project column
      controls.domElement.addEventListener('wheel', function(event) {
        if (projectColumn.contains(event.target)) {
          return;
        }
        event.preventDefault();
      });

      // Create project cards dynamically
      function createProjectCards(projects) {
        projectColumn.innerHTML = ''; // Clear existing cards
        projects.forEach((project, index) => {

          const card = document.createElement('div');
          card.classList.add('project-card');
          card.id = `project-card-${index + 1}`;
          card.innerHTML = `
            <img src="${project.image}" alt="${project.title}">
            <div class="project-details">
              <h3>${project.title}</h3>
              <p>${project.description}</p>
              <a href="${project.readMoreLink}" target="_blank" class="read-more">Read More</a>
            </div>`;
          projectColumn.appendChild(card);
        });
      }

      // Show Project Cards on Ray Hover
      function showProjectCard(index) {
        const projectCards = document.querySelectorAll('.project-card');
        projectCards.forEach((card) => card.classList.remove('active'));
        const selectedCard = document.getElementById(`project-card-${index + 1}`);
        if (selectedCard) {
          selectedCard.classList.add('active');
          selectedCard.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }
      
      // Function to handle ray intersection and show project card
      function handleRayInteraction(event) {
        event.preventDefault();
        const rect = renderer.domElement.getBoundingClientRect();
        let clientX, clientY;

        if (event.type === 'touchstart' || event.type === 'touchmove') {
          clientX = event.touches[0].clientX;
          clientY = event.touches[0].clientY;
        } else {
          clientX = event.clientX;
          clientY = event.clientY;
        }

        mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects([...projectRays, ...baseDots], true);

        // Reset all ray and dot colors
        projectRays.forEach((ray) => ray.material.color.set(0xffffff));
        baseDots.forEach((dot) => dot.material.color.set(0xffffff));

        if (intersects.length > 0) {
          const intersectedObject = intersects[0].object;

          // Highlight the ray or dot
          intersectedObject.material.color.set(0xffa500); // Orange highlight

          // Show the corresponding project card
          if (intersectedObject.userData.projectIndex !== undefined) {
            showProjectCard(intersectedObject.userData.projectIndex);
          }
        }
      }

      // Event listeners for mouse and touch interactions
      container.addEventListener('mousemove', handleRayInteraction);
      container.addEventListener('click', handleRayInteraction);
      container.addEventListener('touchstart', handleRayInteraction);
      container.addEventListener('touchmove', handleRayInteraction);

      container.addEventListener('mousemove', function (event) {
        event.preventDefault();
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        intersectsDot = raycaster.intersectObjects([...projectRays, ...baseDots], true);

        if (intersectsDot.length > 0) { // Check if clicked on a dot (if necessary)
            const intersectedDot = intersectsDot[0].object;
            intersectedDot.material.color.set(0xffa500); // Highlight dot
            if (intersectedDot.userData.projectIndex !== undefined) {
                showProjectCard(intersectedDot.userData.projectIndex); // Show corresponding project card
            }
        } else {

            // Reset all colors when no intersection
            projectRays.forEach((ray) => ray.material.color.set(0xffffff)); // Reset project ray color
            baseDots.forEach((dot) => dot.material.color.set(0xffffff)); // Reset dot color
        }
    });
     
      container.addEventListener('click', function (event) {
        event.preventDefault();
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        intersectsDot = raycaster.intersectObjects([...projectRays, ...baseDots], true);

        if (intersectsDot.length > 0) { // Check if clicked on a dot (if necessary)
            const intersectedDot = intersectsDot[0].object;
            intersectedDot.material.color.set(0xffa500); // Highlight dot
            if (intersectedDot.userData.projectIndex !== undefined) {
                showProjectCard(intersectedDot.userData.projectIndex); // Show corresponding project card
            }
        } else {
            // Reset all colors when no intersection
            extraRays.forEach((ray) => ray.material.color.set(0xffffff)); // Reset extra ray color
            baseDots.forEach((dot) => dot.material.color.set(0xffffff)); // Reset dot color
        }
      });
     
      function handleTouch(event) {
        event.preventDefault();
        const rect = renderer.domElement.getBoundingClientRect();
        const touch = event.touches[0];

        mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        const intersectedObjects = raycaster.intersectObjects([...baseDots], true);
        if (intersectedObjects.length > 0) {
          const intersectedDot = intersectedObjects[0].object;
          intersectedDot.material.color.set(0xffa500); // Highlight dot
          intersectedDot.material.emissiveIntensity = 0.5; // Enhance feedback

          if (intersectedDot.userData.projectIndex !== undefined) {
            showProjectCard(intersectedDot.userData.projectIndex);
          }
        }
      }

      // Add event listeners for touch
      container.addEventListener("touchstart", handleTouch);
      container.addEventListener("touchend", handleTouch);
      container.addEventListener("touchmove", handleTouch);

      let backgroundAngle = 0; // Initialize the background angle for continuous motion

      // Function to update the background position based on both globe rotation and continuous motion
      function updateBackgroundPosition() {
        backgroundAngle += 0.002; // Adjust speed of continuous rotation as needed

        // Continuous circular motion for background
        const continuousPosX = 20 * Math.sin(backgroundAngle);
        const continuousPosY = 20 * Math.cos(backgroundAngle);

        // Get the globe's manual rotation angles
        const azimuthalAngle = controls.getAzimuthalAngle(); // Horizontal rotation (left/right)
        const polarAngle = controls.getPolarAngle();         // Vertical rotation (up/down)

        // Manual movement based on globe's rotation
        const manualPosX = (azimuthalAngle / (2 * Math.PI)) * 100;
        const manualPosY = (polarAngle / Math.PI) * 100;

        // Combine continuous motion with manual movement
        const backgroundPosX = 50 + continuousPosX + manualPosX;
        const backgroundPosY = 50 + continuousPosY - manualPosY;

        // Apply the new background position
        document.querySelector('.section-container').style.backgroundPosition = `${backgroundPosX}% ${backgroundPosY}%`;
      }

      // Resize Handling
      container.addEventListener('resize', resizeCanvas);

      // Animate Globe
      function animate() {
        requestAnimationFrame(animate);
        controls.update();            // Allow manual globe rotation
        updateBackgroundPosition();   // Update the background position continuously and based on camera movement
        renderer.render(scene, camera);
      }

      // Start the animation loop
      animate();

      // Create project cards
      createProjectCards(projectData);

      // Initial resize call to fix any initial canvas sizing issues
      resizeCanvas();
    });
  </script>
</body>
</html>
